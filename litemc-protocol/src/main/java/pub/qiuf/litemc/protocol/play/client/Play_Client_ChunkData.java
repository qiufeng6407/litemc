package pub.qiuf.litemc.protocol.play.client;

import pub.qiuf.litemc.common.bean.datatype.Packet;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;
import pub.qiuf.litemc.common.util.ByteUtils;
import com.flowpowered.nbt.Tag;
import pub.qiuf.litemc.common.annotation.MCType;
import com.google.common.io.ByteArrayDataOutput;
import pub.qiuf.litemc.common.annotation.ServerPacket;
import lombok.Data;
import pub.qiuf.litemc.common.util.StreamUtils;

/**
 * Code is generated by <code>pub.qiuf.litemc.generator.ProtocolGenerator</code>, Please don't modify.<br>
 * See more detail from <a>https://wiki.vg/Protocol</a><br>
 */
@Data
@ServerPacket(0x22)
public class Play_Client_ChunkData extends Packet {
    /** Packet ID */
    @MCType("VarInt")
    private int packetId = 0x22;
    /** Chunk coordinate (block coordinate divided by 16, rounded down) */
    @MCType("Int")
    private int chunkX;
    /** Chunk coordinate (block coordinate divided by 16, rounded down) */
    @MCType("Int")
    private int chunkZ;
    /** See Chunk Format */
    @MCType("Boolean")
    private boolean fullChunk;
    /** Bitmask with bits set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from y=0 to y=15). */
    @MCType("VarInt")
    private int primaryBitMask;
    /** Compound containing one long array named MOTION_BLOCKING, which is a heightmap for the highest solid block at each position in the chunk (as a compacted long array with 256 entries at 9 bits per entry totaling 36 longs). The Notchian server also adds a WORLD_SURFACE long array, the purpose of which is unknown, but it's not required for the chunk to be accepted. */
    @MCType("Tag")
    private Tag heightmaps;
    /** 1024 biome IDs, ordered by x then z then y, in 4×4×4 blocks. Not present if full chunk is false. */
    @MCType("Int")
    private int[] biomes;
    /** Size of Data in bytes */
    @MCType("VarInt")
    private int size;
    /** See data structure in Chunk Format */
    @MCType("Byte")
    private byte[] data;
    /** Number of elements in the following array */
    @MCType("VarInt")
    private int numberOfBlockEntities;
    /** All block entities in the chunk. Use the x, y, and z tags in the NBT to determine their positions. */
    @MCType("Tag")
    private Tag[] blockEntities;

    @Override
    public byte[] encode() throws Exception {
        ByteArrayDataOutput packet = ByteStreams.newDataOutput();
        // Packet ID
        packet.write(ByteUtils.encodeVarInt(packetId));
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        packet.write(ByteUtils.encodeInt(chunkX));
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        packet.write(ByteUtils.encodeInt(chunkZ));
        // See Chunk Format
        packet.write(ByteUtils.encodeBoolean(fullChunk));
        // Bitmask with bits set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from y=0 to y=15).
        packet.write(ByteUtils.encodeVarInt(primaryBitMask));
        // Compound containing one long array named MOTION_BLOCKING, which is a heightmap for the highest solid block at each position in the chunk (as a compacted long array with 256 entries at 9 bits per entry totaling 36 longs). The Notchian server also adds a WORLD_SURFACE long array, the purpose of which is unknown, but it's not required for the chunk to be accepted.
        packet.write(ByteUtils.encodeTag(heightmaps));
        // 1024 biome IDs, ordered by x then z then y, in 4×4×4 blocks. Not present if full chunk is false.
        for (int temp : biomes) {
            packet.write(ByteUtils.encodeInt(temp));
        }
        // Size of Data in bytes
        packet.write(ByteUtils.encodeVarInt(size));
        // See data structure in Chunk Format
        packet.write(data);
        // Number of elements in the following array
        packet.write(ByteUtils.encodeVarInt(numberOfBlockEntities));
        // All block entities in the chunk. Use the x, y, and z tags in the NBT to determine their positions.
        for (Tag temp : blockEntities) {
            packet.write(ByteUtils.encodeTag(temp));
        }
        return packet.toByteArray();
    }
    @Override
    public void decode(ByteArrayDataInput in) throws Exception {
        // Packet ID
        packetId = StreamUtils.readVarInt(in);
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        chunkX = StreamUtils.readInt(in);
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        chunkZ = StreamUtils.readInt(in);
        // See Chunk Format
        fullChunk = StreamUtils.readBoolean(in);
        // Bitmask with bits set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from y=0 to y=15).
        primaryBitMask = StreamUtils.readVarInt(in);
        // Compound containing one long array named MOTION_BLOCKING, which is a heightmap for the highest solid block at each position in the chunk (as a compacted long array with 256 entries at 9 bits per entry totaling 36 longs). The Notchian server also adds a WORLD_SURFACE long array, the purpose of which is unknown, but it's not required for the chunk to be accepted.
        heightmaps = StreamUtils.readTag(in);
        // 1024 biome IDs, ordered by x then z then y, in 4×4×4 blocks. Not present if full chunk is false.
        // TODO decode biomes
        // Size of Data in bytes
        size = StreamUtils.readVarInt(in);
        // See data structure in Chunk Format
        // TODO decode data
        // Number of elements in the following array
        numberOfBlockEntities = StreamUtils.readVarInt(in);
        // All block entities in the chunk. Use the x, y, and z tags in the NBT to determine their positions.
        blockEntities = new Tag[numberOfBlockEntities];
        for (int i = 0; i < blockEntities.length; i++) {
            blockEntities[i] = StreamUtils.readTag(in);
        }
    }
    public static class Play_Client_ChunkData_Builder {
        private Play_Client_ChunkData object = new Play_Client_ChunkData();
        /** Packet ID */
        public Play_Client_ChunkData_Builder packetId(int packetId) {
            object.packetId = packetId;
            return this;
        }
        /** Chunk coordinate (block coordinate divided by 16, rounded down) */
        public Play_Client_ChunkData_Builder chunkX(int chunkX) {
            object.chunkX = chunkX;
            return this;
        }
        /** Chunk coordinate (block coordinate divided by 16, rounded down) */
        public Play_Client_ChunkData_Builder chunkZ(int chunkZ) {
            object.chunkZ = chunkZ;
            return this;
        }
        /** See Chunk Format */
        public Play_Client_ChunkData_Builder fullChunk(boolean fullChunk) {
            object.fullChunk = fullChunk;
            return this;
        }
        /** Bitmask with bits set to 1 for every 16×16×16 chunk section whose data is included in Data. The least significant bit represents the chunk section at the bottom of the chunk column (from y=0 to y=15). */
        public Play_Client_ChunkData_Builder primaryBitMask(int primaryBitMask) {
            object.primaryBitMask = primaryBitMask;
            return this;
        }
        /** Compound containing one long array named MOTION_BLOCKING, which is a heightmap for the highest solid block at each position in the chunk (as a compacted long array with 256 entries at 9 bits per entry totaling 36 longs). The Notchian server also adds a WORLD_SURFACE long array, the purpose of which is unknown, but it's not required for the chunk to be accepted. */
        public Play_Client_ChunkData_Builder heightmaps(Tag heightmaps) {
            object.heightmaps = heightmaps;
            return this;
        }
        /** 1024 biome IDs, ordered by x then z then y, in 4×4×4 blocks. Not present if full chunk is false. */
        public Play_Client_ChunkData_Builder biomes(int[] biomes) {
            object.biomes = biomes;
            return this;
        }
        /** Size of Data in bytes */
        public Play_Client_ChunkData_Builder size(int size) {
            object.size = size;
            return this;
        }
        /** See data structure in Chunk Format */
        public Play_Client_ChunkData_Builder data(byte[] data) {
            object.data = data;
            return this;
        }
        /** Number of elements in the following array */
        public Play_Client_ChunkData_Builder numberOfBlockEntities(int numberOfBlockEntities) {
            object.numberOfBlockEntities = numberOfBlockEntities;
            return this;
        }
        /** All block entities in the chunk. Use the x, y, and z tags in the NBT to determine their positions. */
        public Play_Client_ChunkData_Builder blockEntities(Tag[] blockEntities) {
            object.blockEntities = blockEntities;
            return this;
        }
        public Play_Client_ChunkData build() {
             return object;
        }

    }
    public static Play_Client_ChunkData_Builder builder() {
        return new Play_Client_ChunkData_Builder();
    }
}