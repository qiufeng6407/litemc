package pub.qiuf.litemc.protocol.play.client;

import pub.qiuf.litemc.common.bean.datatype.Packet;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;
import pub.qiuf.litemc.common.util.ByteUtils;
import pub.qiuf.litemc.common.annotation.MCType;
import com.google.common.io.ByteArrayDataOutput;
import pub.qiuf.litemc.common.bean.datatype.Slot;
import pub.qiuf.litemc.common.annotation.ServerPacket;
import lombok.Data;
import pub.qiuf.litemc.common.util.StreamUtils;

/**
 * Code is generated by <code>pub.qiuf.litemc.generator.ProtocolGenerator</code>, Please don't modify.<br>
 * See more detail from <a>https://wiki.vg/Protocol</a><br>
 */
@Data
@ServerPacket(0x17)
public class Play_Client_SetSlot extends Packet {
    /** Packet ID */
    @MCType("VarInt")
    private int packetId = 0x17;
    /** The window which is being updated. 0 for player inventory. Note that all known window types include the player inventory. This packet will only be sent for the currently opened window while the player is performing actions, even if it affects the player inventory. After the window is closed, a number of these packets are sent to update the player's inventory window (0). */
    @MCType("Byte")
    private byte windowId;
    /** The slot that should be updated */
    @MCType("Short")
    private short slot;
    @MCType("Slot")
    private Slot slotData;

    @Override
    public byte[] encode() throws Exception {
        ByteArrayDataOutput packet = ByteStreams.newDataOutput();
        // Packet ID
        packet.write(ByteUtils.encodeVarInt(packetId));
        // The window which is being updated. 0 for player inventory. Note that all known window types include the player inventory. This packet will only be sent for the currently opened window while the player is performing actions, even if it affects the player inventory. After the window is closed, a number of these packets are sent to update the player's inventory window (0).
        packet.write(ByteUtils.encodeByte(windowId));
        // The slot that should be updated
        packet.write(ByteUtils.encodeShort(slot));
        packet.write(ByteUtils.encodeSlot(slotData));
        return packet.toByteArray();
    }
    @Override
    public void decode(ByteArrayDataInput in) throws Exception {
        // Packet ID
        packetId = StreamUtils.readVarInt(in);
        // The window which is being updated. 0 for player inventory. Note that all known window types include the player inventory. This packet will only be sent for the currently opened window while the player is performing actions, even if it affects the player inventory. After the window is closed, a number of these packets are sent to update the player's inventory window (0).
        windowId = StreamUtils.readByte(in);
        // The slot that should be updated
        slot = StreamUtils.readShort(in);
        slotData = StreamUtils.readSlot(in);
    }
    public static class Play_Client_SetSlot_Builder {
        private Play_Client_SetSlot object = new Play_Client_SetSlot();
        /** Packet ID */
        public Play_Client_SetSlot_Builder packetId(int packetId) {
            object.packetId = packetId;
            return this;
        }
        /** The window which is being updated. 0 for player inventory. Note that all known window types include the player inventory. This packet will only be sent for the currently opened window while the player is performing actions, even if it affects the player inventory. After the window is closed, a number of these packets are sent to update the player's inventory window (0). */
        public Play_Client_SetSlot_Builder windowId(byte windowId) {
            object.windowId = windowId;
            return this;
        }
        /** The slot that should be updated */
        public Play_Client_SetSlot_Builder slot(short slot) {
            object.slot = slot;
            return this;
        }
        public Play_Client_SetSlot_Builder slotData(Slot slotData) {
            object.slotData = slotData;
            return this;
        }
        public Play_Client_SetSlot build() {
             return object;
        }

    }
    public static Play_Client_SetSlot_Builder builder() {
        return new Play_Client_SetSlot_Builder();
    }
}