package pub.qiuf.litemc.protocol.play.client;

import pub.qiuf.litemc.common.bean.datatype.Packet;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;
import pub.qiuf.litemc.common.util.ByteUtils;
import pub.qiuf.litemc.common.annotation.MCType;
import com.google.common.io.ByteArrayDataOutput;
import pub.qiuf.litemc.common.annotation.ServerPacket;
import lombok.Data;
import pub.qiuf.litemc.common.util.StreamUtils;

/**
 * Code is generated by <code>pub.qiuf.litemc.generator.ProtocolGenerator</code>, Please don't modify.<br>
 * See more detail from <a>https://wiki.vg/Protocol</a><br>
 */
@Data
@ServerPacket(0x27)
public class Play_Client_MapData extends Packet {
    /** Packet ID */
    @MCType("VarInt")
    private int packetId = 0x27;
    /** Map ID of the map being modified */
    @MCType("VarInt")
    private int mapId;
    /** From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel) */
    @MCType("Byte")
    private byte scale;
    /** Specifies whether player and item frame icons are shown */
    @MCType("Boolean")
    private boolean trackingPosition;
    /** True if the map has been locked in a cartography table */
    @MCType("Boolean")
    private boolean locked;
    /** Number of elements in the following array */
    @MCType("VarInt")
    private int iconCount;
    @MCType("Play_Client_MapData_Icon")
    private Play_Client_MapData_Icon[] icon;
    /** Number of columns updated */
    @MCType("UnsignedByte")
    private int columns;
    /** Only if Columns is more than 0; number of rows updated */
    @MCType("Byte")
    private byte rows;
    /** Only if Columns is more than 0; x offset of the westernmost column */
    @MCType("Byte")
    private byte x;
    /** Only if Columns is more than 0; z offset of the northernmost row */
    @MCType("Byte")
    private byte z;
    /** Only if Columns is more than 0; length of the following array */
    @MCType("VarInt")
    private int length;
    /** Only if Columns is more than 0; see Map item format */
    @MCType("UnsignedByte")
    private int[] data;

    @Override
    public byte[] encode() throws Exception {
        ByteArrayDataOutput packet = ByteStreams.newDataOutput();
        // Packet ID
        packet.write(ByteUtils.encodeVarInt(packetId));
        // Map ID of the map being modified
        packet.write(ByteUtils.encodeVarInt(mapId));
        // From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel)
        packet.write(ByteUtils.encodeByte(scale));
        // Specifies whether player and item frame icons are shown
        packet.write(ByteUtils.encodeBoolean(trackingPosition));
        // True if the map has been locked in a cartography table
        packet.write(ByteUtils.encodeBoolean(locked));
        // Number of elements in the following array
        packet.write(ByteUtils.encodeVarInt(iconCount));
        for (Play_Client_MapData_Icon temp : icon) {
            packet.write(temp.encode());
        }
        // Number of columns updated
        packet.write(ByteUtils.encodeUnsignedByte(columns));
        // Only if Columns is more than 0; number of rows updated
        packet.write(ByteUtils.encodeByte(rows));
        // Only if Columns is more than 0; x offset of the westernmost column
        packet.write(ByteUtils.encodeByte(x));
        // Only if Columns is more than 0; z offset of the northernmost row
        packet.write(ByteUtils.encodeByte(z));
        // Only if Columns is more than 0; length of the following array
        packet.write(ByteUtils.encodeVarInt(length));
        // Only if Columns is more than 0; see Map item format
        for (int temp : data) {
            packet.write(ByteUtils.encodeInt(temp));
        }
        return packet.toByteArray();
    }
    @Override
    public void decode(ByteArrayDataInput in) throws Exception {
        // Packet ID
        packetId = StreamUtils.readVarInt(in);
        // Map ID of the map being modified
        mapId = StreamUtils.readVarInt(in);
        // From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel)
        scale = StreamUtils.readByte(in);
        // Specifies whether player and item frame icons are shown
        trackingPosition = StreamUtils.readBoolean(in);
        // True if the map has been locked in a cartography table
        locked = StreamUtils.readBoolean(in);
        // Number of elements in the following array
        iconCount = StreamUtils.readVarInt(in);
        icon = new Play_Client_MapData_Icon[iconCount];
        for (int i = 0; i < icon.length; i++) {
            icon[i] = new Play_Client_MapData_Icon();
            icon[i].decode(in);
        }
        // Number of columns updated
        columns = StreamUtils.readUnsignedByte(in);
        // Only if Columns is more than 0; number of rows updated
        rows = StreamUtils.readByte(in);
        // Only if Columns is more than 0; x offset of the westernmost column
        x = StreamUtils.readByte(in);
        // Only if Columns is more than 0; z offset of the northernmost row
        z = StreamUtils.readByte(in);
        // Only if Columns is more than 0; length of the following array
        length = StreamUtils.readVarInt(in);
        // Only if Columns is more than 0; see Map item format
        data = new int[length];
        for (int i = 0; i < data.length; i++) {
            data[i] = StreamUtils.readUnsignedByte(in);
        }
    }
    @Data
    public static class Play_Client_MapData_Icon extends Packet {
        /** See below */
        @MCType("VarInt")
        private int type;
        /** Map coordinates: -128 for furthest left, +127 for furthest right */
        @MCType("Byte")
        private byte x;
        /** Map coordinates: -128 for highest, +127 for lowest */
        @MCType("Byte")
        private byte z;
        /** 0-15 */
        @MCType("Byte")
        private byte direction;
        @MCType("Boolean")
        private boolean hasDisplayName;
        /** Only present if previous Boolean is true */
        @MCType("Chat")
        private String displayName;

        @Override
        public byte[] encode() throws Exception {
            ByteArrayDataOutput packet = ByteStreams.newDataOutput();
            // See below
            packet.write(ByteUtils.encodeVarInt(type));
            // Map coordinates: -128 for furthest left, +127 for furthest right
            packet.write(ByteUtils.encodeByte(x));
            // Map coordinates: -128 for highest, +127 for lowest
            packet.write(ByteUtils.encodeByte(z));
            // 0-15
            packet.write(ByteUtils.encodeByte(direction));
            packet.write(ByteUtils.encodeBoolean(hasDisplayName));
            // Only present if previous Boolean is true
            packet.write(ByteUtils.encodeChat(displayName));
            return packet.toByteArray();
        }
        @Override
        public void decode(ByteArrayDataInput in) throws Exception {
            // See below
            type = StreamUtils.readVarInt(in);
            // Map coordinates: -128 for furthest left, +127 for furthest right
            x = StreamUtils.readByte(in);
            // Map coordinates: -128 for highest, +127 for lowest
            z = StreamUtils.readByte(in);
            // 0-15
            direction = StreamUtils.readByte(in);
            hasDisplayName = StreamUtils.readBoolean(in);
            // Only present if previous Boolean is true
            displayName = StreamUtils.readChat(in);
        }
    }
    @FunctionalInterface
    public interface Play_Client_MapData_Icon_Provider {
        Play_Client_MapData_Icon[] provide();
    }
    public static Play_Client_MapData_Icon_Builder iconBuilder() {
        return new Play_Client_MapData_Icon_Builder();
    }
    public static class Play_Client_MapData_Icon_Builder {
        private Play_Client_MapData_Icon object = new Play_Client_MapData_Icon();
        /** See below */
        public Play_Client_MapData_Icon_Builder type(int type) {
            object.type = type;
            return this;
        }
        /** Map coordinates: -128 for furthest left, +127 for furthest right */
        public Play_Client_MapData_Icon_Builder x(byte x) {
            object.x = x;
            return this;
        }
        /** Map coordinates: -128 for highest, +127 for lowest */
        public Play_Client_MapData_Icon_Builder z(byte z) {
            object.z = z;
            return this;
        }
        /** 0-15 */
        public Play_Client_MapData_Icon_Builder direction(byte direction) {
            object.direction = direction;
            return this;
        }
        public Play_Client_MapData_Icon_Builder hasDisplayName(boolean hasDisplayName) {
            object.hasDisplayName = hasDisplayName;
            return this;
        }
        /** Only present if previous Boolean is true */
        public Play_Client_MapData_Icon_Builder displayName(String displayName) {
            object.displayName = displayName;
            return this;
        }
        public Play_Client_MapData_Icon build() {
             return object;
        }

    }
    public static class Play_Client_MapData_Builder {
        private Play_Client_MapData object = new Play_Client_MapData();
        /** Packet ID */
        public Play_Client_MapData_Builder packetId(int packetId) {
            object.packetId = packetId;
            return this;
        }
        /** Map ID of the map being modified */
        public Play_Client_MapData_Builder mapId(int mapId) {
            object.mapId = mapId;
            return this;
        }
        /** From 0 for a fully zoomed-in map (1 block per pixel) to 4 for a fully zoomed-out map (16 blocks per pixel) */
        public Play_Client_MapData_Builder scale(byte scale) {
            object.scale = scale;
            return this;
        }
        /** Specifies whether player and item frame icons are shown */
        public Play_Client_MapData_Builder trackingPosition(boolean trackingPosition) {
            object.trackingPosition = trackingPosition;
            return this;
        }
        /** True if the map has been locked in a cartography table */
        public Play_Client_MapData_Builder locked(boolean locked) {
            object.locked = locked;
            return this;
        }
        /** Number of elements in the following array */
        public Play_Client_MapData_Builder iconCount(int iconCount) {
            object.iconCount = iconCount;
            return this;
        }
        public Play_Client_MapData_Builder icon(Play_Client_MapData_Icon_Provider provider) {
            object.icon = provider.provide();
            return this;
        }
        /** Number of columns updated */
        public Play_Client_MapData_Builder columns(int columns) {
            object.columns = columns;
            return this;
        }
        /** Only if Columns is more than 0; number of rows updated */
        public Play_Client_MapData_Builder rows(byte rows) {
            object.rows = rows;
            return this;
        }
        /** Only if Columns is more than 0; x offset of the westernmost column */
        public Play_Client_MapData_Builder x(byte x) {
            object.x = x;
            return this;
        }
        /** Only if Columns is more than 0; z offset of the northernmost row */
        public Play_Client_MapData_Builder z(byte z) {
            object.z = z;
            return this;
        }
        /** Only if Columns is more than 0; length of the following array */
        public Play_Client_MapData_Builder length(int length) {
            object.length = length;
            return this;
        }
        /** Only if Columns is more than 0; see Map item format */
        public Play_Client_MapData_Builder data(int[] data) {
            object.data = data;
            return this;
        }
        public Play_Client_MapData build() {
             return object;
        }

    }
    public static Play_Client_MapData_Builder builder() {
        return new Play_Client_MapData_Builder();
    }
}