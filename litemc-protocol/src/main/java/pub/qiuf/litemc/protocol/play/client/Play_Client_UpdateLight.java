package pub.qiuf.litemc.protocol.play.client;

import pub.qiuf.litemc.common.bean.datatype.Packet;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;
import pub.qiuf.litemc.common.util.ByteUtils;
import pub.qiuf.litemc.common.annotation.MCType;
import com.google.common.io.ByteArrayDataOutput;
import pub.qiuf.litemc.common.annotation.ServerPacket;
import lombok.Data;
import pub.qiuf.litemc.common.util.StreamUtils;

/**
 * Code is generated by <code>pub.qiuf.litemc.generator.ProtocolGenerator</code>, Please don't modify.<br>
 * See more detail from <a>https://wiki.vg/Protocol</a><br>
 */
@Data
@ServerPacket(0x25)
public class Play_Client_UpdateLight extends Packet {
    /** Packet ID */
    @MCType("VarInt")
    private int packetId = 0x25;
    /** Chunk coordinate (block coordinate divided by 16, rounded down) */
    @MCType("VarInt")
    private int chunkX;
    /** Chunk coordinate (block coordinate divided by 16, rounded down) */
    @MCType("VarInt")
    private int chunkZ;
    /** Mask containing 18 bits, with the lowest bit corresponding to chunk section -1 (in the void, y=-16 to y=-1) and the highest bit for chunk section 16 (above the world, y=256 to y=271) */
    @MCType("VarInt")
    private int skyLightMask;
    /** Mask containing 18 bits, with the same order as sky light */
    @MCType("VarInt")
    private int blockLightMask;
    /** Mask containing 18 bits, which indicates sections that have 0 for all their sky light values. If a section is set in both this mask and the main sky light mask, it is ignored for this mask and it is included in the sky light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the sky light arrays. */
    @MCType("VarInt")
    private int emptySkyLightMask;
    /** Mask containing 18 bits, which indicates sections that have 0 for all their block light values. If a section is set in both this mask and the main block light mask, it is ignored for this mask and it is included in the block light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the block light arrays. */
    @MCType("VarInt")
    private int emptyBlockLightMask;
    @MCType("Play_Client_UpdateLight_SkyLightArrays")
    private Play_Client_UpdateLight_SkyLightArrays skyLightArrays;
    @MCType("Play_Client_UpdateLight_BlockLightArrays")
    private Play_Client_UpdateLight_BlockLightArrays blockLightArrays;

    @Override
    public byte[] encode() throws Exception {
        ByteArrayDataOutput packet = ByteStreams.newDataOutput();
        // Packet ID
        packet.write(ByteUtils.encodeVarInt(packetId));
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        packet.write(ByteUtils.encodeVarInt(chunkX));
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        packet.write(ByteUtils.encodeVarInt(chunkZ));
        // Mask containing 18 bits, with the lowest bit corresponding to chunk section -1 (in the void, y=-16 to y=-1) and the highest bit for chunk section 16 (above the world, y=256 to y=271)
        packet.write(ByteUtils.encodeVarInt(skyLightMask));
        // Mask containing 18 bits, with the same order as sky light
        packet.write(ByteUtils.encodeVarInt(blockLightMask));
        // Mask containing 18 bits, which indicates sections that have 0 for all their sky light values. If a section is set in both this mask and the main sky light mask, it is ignored for this mask and it is included in the sky light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the sky light arrays.
        packet.write(ByteUtils.encodeVarInt(emptySkyLightMask));
        // Mask containing 18 bits, which indicates sections that have 0 for all their block light values. If a section is set in both this mask and the main block light mask, it is ignored for this mask and it is included in the block light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the block light arrays.
        packet.write(ByteUtils.encodeVarInt(emptyBlockLightMask));
        packet.write(skyLightArrays.encode());
        packet.write(blockLightArrays.encode());
        return packet.toByteArray();
    }
    @Override
    public void decode(ByteArrayDataInput in) throws Exception {
        // Packet ID
        packetId = StreamUtils.readVarInt(in);
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        chunkX = StreamUtils.readVarInt(in);
        // Chunk coordinate (block coordinate divided by 16, rounded down)
        chunkZ = StreamUtils.readVarInt(in);
        // Mask containing 18 bits, with the lowest bit corresponding to chunk section -1 (in the void, y=-16 to y=-1) and the highest bit for chunk section 16 (above the world, y=256 to y=271)
        skyLightMask = StreamUtils.readVarInt(in);
        // Mask containing 18 bits, with the same order as sky light
        blockLightMask = StreamUtils.readVarInt(in);
        // Mask containing 18 bits, which indicates sections that have 0 for all their sky light values. If a section is set in both this mask and the main sky light mask, it is ignored for this mask and it is included in the sky light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the sky light arrays.
        emptySkyLightMask = StreamUtils.readVarInt(in);
        // Mask containing 18 bits, which indicates sections that have 0 for all their block light values. If a section is set in both this mask and the main block light mask, it is ignored for this mask and it is included in the block light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the block light arrays.
        emptyBlockLightMask = StreamUtils.readVarInt(in);
        skyLightArrays = new Play_Client_UpdateLight_SkyLightArrays();
        skyLightArrays.decode(in);
        blockLightArrays = new Play_Client_UpdateLight_BlockLightArrays();
        blockLightArrays.decode(in);
    }
    @Data
    public static class Play_Client_UpdateLight_SkyLightArrays extends Packet {
        /** Length of the following array in bytes (always 2048) */
        @MCType("VarInt")
        private int length;
        /** There is 1 array for each bit set to true in the sky light mask, starting with the lowest value. Half a byte per light value. */
        @MCType("Byte")
        private byte[] skyLightArray = new byte[2048];

        @Override
        public byte[] encode() throws Exception {
            ByteArrayDataOutput packet = ByteStreams.newDataOutput();
            // Length of the following array in bytes (always 2048)
            packet.write(ByteUtils.encodeVarInt(length));
            // There is 1 array for each bit set to true in the sky light mask, starting with the lowest value. Half a byte per light value.
            packet.write(skyLightArray);
            return packet.toByteArray();
        }
        @Override
        public void decode(ByteArrayDataInput in) throws Exception {
            // Length of the following array in bytes (always 2048)
            length = StreamUtils.readVarInt(in);
            // There is 1 array for each bit set to true in the sky light mask, starting with the lowest value. Half a byte per light value.
            skyLightArray = new byte[length];
            for (int i = 0; i < skyLightArray.length; i++) {
                skyLightArray[i] = StreamUtils.readByte(in);
            }
        }
    }
    @FunctionalInterface
    public interface Play_Client_UpdateLight_SkyLightArrays_Provider {
        Play_Client_UpdateLight_SkyLightArrays provide();
    }
    public static Play_Client_UpdateLight_SkyLightArrays_Builder skyLightArraysBuilder() {
        return new Play_Client_UpdateLight_SkyLightArrays_Builder();
    }
    public static class Play_Client_UpdateLight_SkyLightArrays_Builder {
        private Play_Client_UpdateLight_SkyLightArrays object = new Play_Client_UpdateLight_SkyLightArrays();
        /** Length of the following array in bytes (always 2048) */
        public Play_Client_UpdateLight_SkyLightArrays_Builder length(int length) {
            object.length = length;
            return this;
        }
        /** There is 1 array for each bit set to true in the sky light mask, starting with the lowest value. Half a byte per light value. */
        public Play_Client_UpdateLight_SkyLightArrays_Builder skyLightArray(byte[] skyLightArray) {
            object.skyLightArray = skyLightArray;
            return this;
        }
        public Play_Client_UpdateLight_SkyLightArrays build() {
             return object;
        }

    }
    @Data
    public static class Play_Client_UpdateLight_BlockLightArrays extends Packet {
        /** Length of the following array in bytes (always 2048) */
        @MCType("VarInt")
        private int length;
        /** There is 1 array for each bit set to true in the block light mask, starting with the lowest value. Half a byte per light value. */
        @MCType("Byte")
        private byte[] blockLightArray = new byte[2048];

        @Override
        public byte[] encode() throws Exception {
            ByteArrayDataOutput packet = ByteStreams.newDataOutput();
            // Length of the following array in bytes (always 2048)
            packet.write(ByteUtils.encodeVarInt(length));
            // There is 1 array for each bit set to true in the block light mask, starting with the lowest value. Half a byte per light value.
            packet.write(blockLightArray);
            return packet.toByteArray();
        }
        @Override
        public void decode(ByteArrayDataInput in) throws Exception {
            // Length of the following array in bytes (always 2048)
            length = StreamUtils.readVarInt(in);
            // There is 1 array for each bit set to true in the block light mask, starting with the lowest value. Half a byte per light value.
            blockLightArray = new byte[length];
            for (int i = 0; i < blockLightArray.length; i++) {
                blockLightArray[i] = StreamUtils.readByte(in);
            }
        }
    }
    @FunctionalInterface
    public interface Play_Client_UpdateLight_BlockLightArrays_Provider {
        Play_Client_UpdateLight_BlockLightArrays provide();
    }
    public static Play_Client_UpdateLight_BlockLightArrays_Builder blockLightArraysBuilder() {
        return new Play_Client_UpdateLight_BlockLightArrays_Builder();
    }
    public static class Play_Client_UpdateLight_BlockLightArrays_Builder {
        private Play_Client_UpdateLight_BlockLightArrays object = new Play_Client_UpdateLight_BlockLightArrays();
        /** Length of the following array in bytes (always 2048) */
        public Play_Client_UpdateLight_BlockLightArrays_Builder length(int length) {
            object.length = length;
            return this;
        }
        /** There is 1 array for each bit set to true in the block light mask, starting with the lowest value. Half a byte per light value. */
        public Play_Client_UpdateLight_BlockLightArrays_Builder blockLightArray(byte[] blockLightArray) {
            object.blockLightArray = blockLightArray;
            return this;
        }
        public Play_Client_UpdateLight_BlockLightArrays build() {
             return object;
        }

    }
    public static class Play_Client_UpdateLight_Builder {
        private Play_Client_UpdateLight object = new Play_Client_UpdateLight();
        /** Packet ID */
        public Play_Client_UpdateLight_Builder packetId(int packetId) {
            object.packetId = packetId;
            return this;
        }
        /** Chunk coordinate (block coordinate divided by 16, rounded down) */
        public Play_Client_UpdateLight_Builder chunkX(int chunkX) {
            object.chunkX = chunkX;
            return this;
        }
        /** Chunk coordinate (block coordinate divided by 16, rounded down) */
        public Play_Client_UpdateLight_Builder chunkZ(int chunkZ) {
            object.chunkZ = chunkZ;
            return this;
        }
        /** Mask containing 18 bits, with the lowest bit corresponding to chunk section -1 (in the void, y=-16 to y=-1) and the highest bit for chunk section 16 (above the world, y=256 to y=271) */
        public Play_Client_UpdateLight_Builder skyLightMask(int skyLightMask) {
            object.skyLightMask = skyLightMask;
            return this;
        }
        /** Mask containing 18 bits, with the same order as sky light */
        public Play_Client_UpdateLight_Builder blockLightMask(int blockLightMask) {
            object.blockLightMask = blockLightMask;
            return this;
        }
        /** Mask containing 18 bits, which indicates sections that have 0 for all their sky light values. If a section is set in both this mask and the main sky light mask, it is ignored for this mask and it is included in the sky light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the sky light arrays. */
        public Play_Client_UpdateLight_Builder emptySkyLightMask(int emptySkyLightMask) {
            object.emptySkyLightMask = emptySkyLightMask;
            return this;
        }
        /** Mask containing 18 bits, which indicates sections that have 0 for all their block light values. If a section is set in both this mask and the main block light mask, it is ignored for this mask and it is included in the block light arrays (the notchian server does not create such masks). If it is only set in this mask, it is not included in the block light arrays. */
        public Play_Client_UpdateLight_Builder emptyBlockLightMask(int emptyBlockLightMask) {
            object.emptyBlockLightMask = emptyBlockLightMask;
            return this;
        }
        public Play_Client_UpdateLight_Builder skyLightArrays(Play_Client_UpdateLight_SkyLightArrays_Provider provider) {
            object.skyLightArrays = provider.provide();
            return this;
        }
        public Play_Client_UpdateLight_Builder blockLightArrays(Play_Client_UpdateLight_BlockLightArrays_Provider provider) {
            object.blockLightArrays = provider.provide();
            return this;
        }
        public Play_Client_UpdateLight build() {
             return object;
        }

    }
    public static Play_Client_UpdateLight_Builder builder() {
        return new Play_Client_UpdateLight_Builder();
    }
}