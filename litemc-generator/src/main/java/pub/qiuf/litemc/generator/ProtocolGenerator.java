package pub.qiuf.litemc.generator;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ProtocolGenerator {
    public static void main(String[] args) throws IOException {
        String path = System.getProperty("user.dir");
        System.out.println(path);
        File file = new File(path, "Protocol.txt");
        Document doc = null;
        if (!file.exists()) {
            doc = Jsoup.connect("https://wiki.vg/Protocol").get();
            FileUtils.write(file, doc.toString(), "GBK");
        } else {
            doc = Jsoup.parse(file, "GBK");
        }

        Element currEle = doc.getElementById("Handshaking").parent();
        Element endEle = doc.getElementById("catlinks");

        String className = null;
        while (currEle != null && currEle != endEle) {
            if ("h4".equals(currEle.tagName())) {
                Element classEle = currEle.getElementsByClass("mw-headline").first();
                className = classEle.text().replaceAll("(\\(.*\\))|\\s|\\-", "");
            } else if ("table".equals(currEle.tagName()) && "Packet ID".equals(currEle.child(0).child(0).child(0).text())) {
                Elements trs = currEle.child(0).children();
                String packetId = trs.get(1).child(0).text();
                String state = trs.get(1).child(1).text();
                String boundTo = trs.get(1).child(2).text();
                String packageInfo = String.format("package pub.qiuf.litemc.protocol.%s.%s;", state.toLowerCase(), boundTo.toLowerCase());
                className = String.format("%s_%s_%s", state, boundTo, className);
                System.out.println("    Creating " + className);

                // 0x34  0x27
                // the following array
                // Determines
                // no fields
                Set<String> imports = new HashSet<>();
                List<_Field> fields = new ArrayList<>();
                List<String> classes = new ArrayList<>();

                _Field packetIdField = new _Field();
                packetIdField.fieldName = "packetId";
                packetIdField.filedType = "int";
                packetIdField.fieldValue = packetId;
                packetIdField.isArray = false;
                packetIdField.fieldNotes = "Packet ID";
                packetIdField.mcType = "VarInt";
                packetIdField.isBaseType = true;
                fields.add(packetIdField);

                imports.add("lombok.Data;");
                imports.add("pub.qiuf.litemc.common.annotation.ServerPacket;");
                imports.add("pub.qiuf.litemc.common.annotation.MCType;");
                imports.add("pub.qiuf.litemc.common.util.ByteUtils;");
                imports.add("pub.qiuf.litemc.common.util.StreamUtils;");
                imports.add("pub.qiuf.litemc.common.bean.datatype.Packet;");
                imports.add("com.google.common.io.ByteArrayDataOutput;");
                imports.add("com.google.common.io.ByteStreams;");
                imports.add("com.google.common.io.ByteArrayDataInput;");

                parseField(trs, 1, trs.size() - 1, 3, -3, imports, classes, fields, false, className);
                addImportString(fields, imports);

                StringBuffer sb = new StringBuffer();
                sb.append(packageInfo).append("\n\n");
                imports.forEach(imp -> {
                    sb.append("import ").append(imp).append("\n");
                });
                sb.append("\n/**\n");
                sb.append(" * Code is generated by <code>pub.qiuf.litemc.generator.ProtocolGenerator</code>, Please don't modify.<br>\n");
                sb.append(" * See more detail from <a>https://wiki.vg/Protocol</a><br>\n");
                sb.append(" */\n");
                sb.append("@Data\n");
                if ("client".equals(boundTo.toLowerCase())) {
                    sb.append("@ServerPacket(").append(packetId).append(")\n");
                }
                sb.append("public class ").append(className).append(" extends Packet {\n");
                sb.append(toClassFieldString(fields, 4)).append("\n");
                sb.append(toEncodeFuncString(fields, 4)).append("\n");
                sb.append(toDecodeFuncString(fields, 4)).append("\n");
                classes.forEach(c -> {
                    sb.append(c).append("\n");
                });
                StringBuffer builderClass = new StringBuffer();
                builderClass.append("    ").append("public static class ").append(className).append("_Builder {\n");
                builderClass.append("        private ").append(className).append(" object = new ").append(className).append("();\n");
                builderClass.append(toBuilderFuncString(className, fields, 8)).append("\n");
                builderClass.append("    ").append("}\n");
                sb.append(builderClass.toString());

                StringBuffer builderFunction = new StringBuffer();
                builderFunction.append("    ").append("public static ").append(className).append("_Builder builder() {\n");
                builderFunction.append("        return new ").append(className).append("_Builder();\n");
                builderFunction.append("    ").append("}\n");
                sb.append(builderFunction.toString());

                sb.append("}");


                String classPath = String.format("%s/pub/qiuf/litemc/protocol/%s/%s", "litemc-protocol\\src\\main\\java", state.toLowerCase(), boundTo.toLowerCase());
                File classFile = new File(path + File.separator + classPath, className + ".java");
                FileUtils.write(classFile, sb.toString(), "UTF-8", false);
                System.out.println("Create " + className + " Success");

            }
            currEle = currEle.nextElementSibling();
        }
    }

    final static Pattern enumPattern = Pattern.compile("^(.+):(.+)$");

    private static void parseField(Elements trs, int row, int endRow, int col, int deltaCol, Set<String> imports, List<String> classes, List<_Field> fields, boolean isArray, String classPrefix) {
        if (row > endRow || col >= trs.get(row).childrenSize()) {
            return;
        }
        final Element element = trs.get(row).child(col);
        if (!"td".equals(element.tagName())) {
            parseField(trs, row + 1, endRow, col, deltaCol, imports, classes, fields, isArray, classPrefix);
            return;
        }
        col += deltaCol;
        int rowspan = getSpan(element, "rowspan");
        int colSize = trs.get(row).childrenSize();
        _Field _field = new _Field();
        _field.isArray = isArray;
        if (rowspan == 1) {
            if ("no fields".equals(element.text())) {
                return;
            }
            analysisFiledName(_field, element.text());
            String fieldTypeText = null;
            if (colSize < 3) {
                fieldTypeText = trs.get(row).child(colSize - 1).text();
            } else {
                _field.fieldNotes = trs.get(row).child(colSize - 1).text();
                fieldTypeText = trs.get(row).child(colSize - 2).text();
            }
            analysisFiledType(_field, fieldTypeText);
            _field.isNextArray = StringUtils.isBlank(_field.fieldNotes) ? false : _field.fieldNotes.contains("the following array");

            Matcher matcher = enumPattern.matcher(element.text());
            if (!matcher.find()) {
                fields.add(_field);
            } else {
                parseField(trs, row, row, col + 1, 0, imports, classes, fields, _field.isNextArray, classPrefix);
            }
            parseField(trs, row + 1, endRow, col, 0, imports, classes, fields, _field.isNextArray, classPrefix);
        } else {
            Matcher matcher = enumPattern.matcher(element.text());
            if (matcher.find()) {
                analysisFiledName(_field, matcher.group(2).trim());
            } else {
                analysisFiledName(_field, element.text());
            }
            _field.filedType = classPrefix + "_" + firstUppercase(_field.fieldName);
            _field.mcType = _field.filedType;
            _field.innerClass = true;
            fields.add(_field);

            List<_Field> subFields = new ArrayList<>();
            parseField(trs, row, row + rowspan - 1, col + 1, -1, imports, classes, subFields, false, _field.filedType);
            addImportString(subFields, imports);

            StringBuffer subClass = new StringBuffer();
            subClass.append("    ").append("@Data").append("\n");
            subClass.append("    ").append("public static class ").append(_field.filedType).append(" extends Packet {\n");
            subClass.append(toClassFieldString(subFields, 8)).append("\n");
            subClass.append(toEncodeFuncString(subFields, 8)).append("\n");
            subClass.append(toDecodeFuncString(subFields, 8)).append("\n");
            subClass.append("    ").append("}");
            classes.add(subClass.toString());

            StringBuffer builderFunctionInterface = new StringBuffer();
            builderFunctionInterface.append("    ").append("@FunctionalInterface").append("\n");
            builderFunctionInterface.append("    ").append("public interface ").append(_field.filedType).append("_Provider {\n");
            builderFunctionInterface.append("        ").append(_field.filedType);
            if (_field.isArray) {
                builderFunctionInterface.append("[]");
            }
            builderFunctionInterface.append(" provide();\n");
            builderFunctionInterface.append("    ").append("}");
            classes.add(builderFunctionInterface.toString());

            StringBuffer builderFunction = new StringBuffer();
            builderFunction.append("    ").append("public static ").append(_field.filedType).append("_Builder ").append(_field.fieldName).append("Builder() {\n");
            builderFunction.append("        return new ").append(_field.filedType).append("_Builder();\n");
            builderFunction.append("    ").append("}");
            classes.add(builderFunction.toString());

            StringBuffer builderClass = new StringBuffer();
            builderClass.append("    ").append("public static class ").append(_field.filedType).append("_Builder {\n");
            builderClass.append("        private ").append(_field.filedType).append(" object = new ").append(_field.filedType).append("();\n");
            builderClass.append(toBuilderFuncString(_field.filedType, subFields, 8)).append("\n");
            builderClass.append("    ").append("}");
            classes.add(builderClass.toString());

            parseField(trs, row + rowspan, endRow, col, 0, imports, classes, fields, false, classPrefix);
        }
    }

    private static class _Field {
        String mcType;
        String fieldName;
        String filedType;
        String fieldNotes;
        String fieldValue;
        boolean isArray;
        boolean isNextArray;
        boolean isBaseType;
        boolean innerClass;
    }

    private static void addImportString(List<_Field> fields, Set<String> imports) {
        fields.forEach(f -> {
            if (f.filedType.startsWith("_") || StringUtils.equalsAny(f.filedType,
                    "Slot", "ModifierData", "Node", "EntityMetadata", "AdvancementProgress", "Advancement", "Varies", "Tags")) {
                imports.add(String.format("pub.qiuf.litemc.common.bean.datatype.%s;", f.filedType));
            } else if (f.filedType.equals("Tag")) {
                imports.add(String.format("com.flowpowered.nbt.Tag;"));
            } else if (f.filedType.equals("UUID")) {
                imports.add(String.format("java.util.UUID;"));
            }
        });

    }

    private static String toEncodeFuncString(List<_Field> fields, int spaceCount) {
        StringBuffer ans = new StringBuffer();
        String space = StringUtils.repeat(' ', spaceCount);
        String space2 = StringUtils.repeat(' ', spaceCount + 4);
        String space3 = StringUtils.repeat(' ', spaceCount + 8);
        ans.append(space).append("@Override\n").append(space).append("public byte[] encode() throws Exception {\n");
        ans.append(space2).append("ByteArrayDataOutput packet = ByteStreams.newDataOutput();\n");
        fields.forEach(f -> {
            if (StringUtils.isNotBlank(f.fieldNotes)) {
                ans.append(space2).append("// ").append(f.fieldNotes).append("\n");
            }
            if (f.isArray) {
                if ("byte".equals(f.filedType)) {
                    ans.append(space2).append("packet.write(").append(f.fieldName).append(");\n");
                } else {
                    ans.append(space2).append("for (").append(f.filedType).append(" temp : ").append(f.fieldName).append(") {\n");
                    ans.append(space3).append("packet.write(");
                    if (f.isBaseType) {
                        ans.append("ByteUtils.encode").append(firstUppercase(f.filedType)).append("(temp)");
                    } else {
                        ans.append("temp.encode()");
                    }
                    ans.append(");\n");
                    ans.append(space2).append("}\n");
                }
            } else {
                ans.append(space2).append("packet.write(");
                if (f.innerClass || f.filedType.startsWith("_")) {
                    ans.append(f.fieldName).append(".encode()");
                } else {
                    ans.append("ByteUtils.encode").append(f.mcType).append("(").append(f.fieldName).append(")");
                }
                ans.append(");\n");
            }
        });
        ans.append(space2).append("return packet.toByteArray();\n");
        ans.append(space).append("}");
        return ans.toString();
    }


    private static String toDecodeFuncString(List<_Field> fields, int spaceCount) {
        StringBuffer ans = new StringBuffer();
        String space = StringUtils.repeat(' ', spaceCount);
        String space2 = StringUtils.repeat(' ', spaceCount + 4);
        String space3 = StringUtils.repeat(' ', spaceCount + 8);
        ans.append(space).append("@Override\n").append(space).append("public void decode(ByteArrayDataInput in) throws Exception {\n");
        for (int i = 0; i < fields.size(); i++) {
            _Field f = fields.get(i);
            if (StringUtils.isNotBlank(f.fieldNotes)) {
                ans.append(space2).append("// ").append(f.fieldNotes).append("\n");
            }
            if ("Packet".equals(f.filedType)) {
                ans.append(space2).append("// TODO decode ").append(f.fieldName).append("\n");
                continue;
            }
            if (f.isArray) {
                if (i > 0 && fields.get(i - 1).fieldNotes.contains("the following array")) {
                    ans.append(space2).append(f.fieldName).append(" = new ").append(f.filedType);
                    ans.append("[").append(fields.get(i - 1).fieldName).append("];\n");
                    ans.append(space2).append("for (int i = 0; i < ").append(f.fieldName).append(".length; i++) {\n");
                    if (f.isBaseType) {
                        ans.append(space3).append(f.fieldName).append("[i] = StreamUtils.read").append(f.mcType).append("(in);\n");
                    } else {
                        ans.append(space3).append(f.fieldName).append("[i] = new ").append(f.mcType).append("();\n");
                        ans.append(space3).append(f.fieldName).append("[i].decode(in);\n");
                    }
                    ans.append(space2).append("}\n");
                } else {
                    ans.append(space2).append("// TODO decode ").append(f.fieldName).append("\n");
                }
            } else {
                if (f.innerClass || f.filedType.startsWith("_")) {
                    ans.append(space2).append(f.fieldName).append(" = new ");
                    if (f.filedType.startsWith("_")) {
                        ans.append("_");
                    }
                    ans.append(f.mcType).append("();\n");
                    ans.append(space2).append(f.fieldName).append(".decode(in);\n");
                } else {
                    ans.append(space2).append(f.fieldName).append(" = StreamUtils.read").append(f.mcType).append("(in);\n");
                }
            }
        }
        ans.append(space).append("}");
        return ans.toString();
    }


    private static String toBuilderFuncString(String className, List<_Field> fields, int spaceCount) {
        StringBuffer ans = new StringBuffer();
        String space = StringUtils.repeat(' ', spaceCount);
        String space2 = StringUtils.repeat(' ', spaceCount + 4);
        String space3 = StringUtils.repeat(' ', spaceCount + 8);
        fields.forEach(f -> {
            if (StringUtils.isNotBlank(f.fieldNotes)) {
                ans.append(space).append("/** ").append(f.fieldNotes).append(" */\n");
            }
            ans.append(space).append("public ").append(className).append("_Builder ").append(f.fieldName).append("(");
            if (f.innerClass) {
                ans.append(f.mcType).append("_Provider provider");
            } else {
                ans.append(f.filedType);
                if (f.isArray) {
                    ans.append("[]");
                }
                ans.append(" ").append(f.fieldName);
            }
            ans.append(") {\n");
            ans.append(space2).append("object.").append(f.fieldName).append(" = ");
            if (f.innerClass) {
                ans.append("provider.provide()");
            } else {
                ans.append(f.fieldName);
            }
            ans.append(";\n");

            ans.append(space2).append("return this;\n");
            ans.append(space).append("}\n");
        });

        ans.append(space).append("public ").append(className).append(" build() {\n");
        ans.append(space2).append(" return object;\n");
        ans.append(space).append("}\n");

        return ans.toString();
    }

    private static String toClassFieldString(List<_Field> fields, int spaceCount) {
        StringBuffer ans = new StringBuffer();
        String space = StringUtils.repeat(' ', spaceCount);
        fields.forEach(f -> {
            if (StringUtils.isNotBlank(f.fieldNotes)) {
                ans.append(space).append("/** ").append(f.fieldNotes).append(" */\n");
            }
            if (StringUtils.isNotBlank(f.mcType)) {
                ans.append(space).append("@MCType(\"").append(f.mcType).append("\")\n");
            }
            ans.append(space).append("private ").append(f.filedType);
            if (f.isArray) {
                ans.append("[]");
            }
            ans.append(" ").append(f.fieldName);
            if (StringUtils.isNotBlank(f.fieldValue)) {
                if (f.isArray) {
                    ans.append(" = new ").append(f.filedType).append("[").append(f.fieldValue).append("]");
                } else if (f.isBaseType) {
                    ans.append(" = ").append(f.fieldValue);
                } else {
                    ans.append(" = new ").append(f.filedType).append("(").append(f.fieldValue).append(")");
                }
            }
            ans.append(";\n");
        });
        return ans.toString();
    }

    /**
     * 根据文本内容解析出fieldName
     *
     * @param fieldName
     * @return
     */
    private static void analysisFiledName(_Field _field, String fieldName) {
        fieldName = fieldName.replaceAll("(\\(.*\\)|\\?|\\-)", "").toLowerCase();
        String[] s = fieldName.split("\\s|/");
        StringBuffer sb = new StringBuffer();
        sb.append(s[0]);
        for (int i = 1; i < s.length; i++) {
            sb.append(firstUppercase(s[i]));
        }
        _field.fieldName = sb.toString();
    }

    /**
     * 根据文本内容解析出filedType
     *
     * @param filedType
     * @return
     */
    private static void analysisFiledType(_Field _field, String filedType) {
        if ("no fields".equals(filedType)) {
            return;
//            Array of (Byte, Byte, Byte)
        } else if ("(See below)".equals(filedType)) {
            _field.filedType = "Tags";
            _field.isBaseType = true;
            _field.mcType = "Tags";
        } else if ("Array of (Byte, Byte, Byte)".equals(filedType)) {
            _field.filedType = "byte";
            _field.isArray = true;
            _field.fieldValue = "3";
            _field.isBaseType = true;
            _field.mcType = "Byte";
        } else if ("Array of 2048 bytes".equals(filedType)) {
            _field.filedType = "byte";
            _field.isArray = true;
            _field.fieldValue = "2048";
            _field.isBaseType = true;
            _field.mcType = "Byte";
        }/* else if ("uuid".equals(_field.fieldName)) {
            _field.filedType = "UUID";
            _field.isBaseType = true;
            _field.mcType = "UUID";
        }*/ else {
            _field.isBaseType = true;
            _field.isArray = StringUtils.containsAny(filedType, "array", "Array");
            String regex = "Optional|optional|Of|of|,|\\|\\-?|Enum|enum|\\(.*\\)|\\(\\d+\\)|\\d+|array|Array";
            filedType = filedType.replaceAll(regex, "").trim();
            String[] s = filedType.split("\\s|/");
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < s.length; i++) {
                sb.append(firstUppercase(s[i]));
            }
            filedType = sb.toString();
            if ("Integer".equals(filedType)) {
                filedType = "Int";
            } else if (StringUtils.containsAny(filedType, "NBT", "NBTTag", "Tag")) {
                filedType = "Tag";
            }
            _field.mcType = filedType;
            if (StringUtils.equalsAny(filedType, "Boolean")) {
                _field.filedType = "boolean";
            } else if (StringUtils.equalsAny(filedType, "UnsignedByte", "UnsignedShort", "VarInt")) {
                _field.filedType = "int";
            } else if (StringUtils.equalsAny(filedType, "VarLong")) {
                _field.filedType = "long";
            } else if (StringUtils.equalsAny(filedType, "Int", "Double", "Float", "Short", "Byte", "Long")) {
                _field.filedType = filedType.toLowerCase();
            } else if (StringUtils.equalsAny(filedType, "String", "Chat", "Identifier")) {
                _field.filedType = "String";
            } else if (StringUtils.equalsAny(filedType, "Position")) {
                _field.filedType = "byte";
                _field.isArray = true;
                _field.fieldValue = "8";
            } else if (StringUtils.equalsAny(filedType, "Angle")) {
                _field.filedType = "byte";
            } else if (StringUtils.equalsAny(filedType, "UUID")) {
                _field.filedType = "long";
                _field.isArray = true;
                _field.fieldValue = "2";
            } else if (StringUtils.equalsAny(filedType,
                    "Tag", "Slot", "ModifierData", "Node", "EntityMetadata", "AdvancementProgress", "Advancement", "Varies")) {
                _field.filedType = filedType;
            } else {
                _field.filedType = "Packet";
            }
        }
    }

    /**
     * 获取Element的space
     *
     * @param element
     * @param name
     * @return
     */
    private static int getSpan(Element element, String name) {
        if (!element.hasAttr(name)) {
            return 1;
        }
        return Integer.parseInt(element.attr(name));
    }

    /**
     * 首字母大写
     *
     * @param fieldName
     * @return
     */
    private static String firstUppercase(String fieldName) {
        if (StringUtils.isBlank(fieldName) || fieldName.length() < 1) {
            return fieldName;
        }
        return fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
    }
}
